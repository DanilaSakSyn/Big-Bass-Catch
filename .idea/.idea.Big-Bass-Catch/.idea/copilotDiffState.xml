<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Project/Scripts/AudioToggleController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Project/Scripts/AudioToggleController.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.Audio;&#10;using UnityEngine.UI;&#10;&#10;public class AudioToggleController : MonoBehaviour&#10;{&#10;    [Header(&quot;Настройки AudioMixer&quot;)]&#10;    [SerializeField] private AudioMixer audioMixer; // Ссылка на AudioMixer&#10;    [SerializeField] private string volumeParameter = &quot;MasterVolume&quot;; // Параметр громкости в AudioMixer&#10;    [SerializeField] private Toggle muteToggle; // Ссылка на Toggle для управления звуком&#10;&#10;    private const float MuteVolume = -80f; // Значение громкости для отключения звука&#10;    private const float UnmuteVolume = 0f; // Значение громкости для включения звука&#10;&#10;    private void Start()&#10;    {&#10;        if (muteToggle != null)&#10;        {&#10;            muteToggle.onValueChanged.AddListener(OnToggleValueChanged);&#10;            // Устанавливаем начальное состояние Toggle в соответствии с текущим состоянием звука&#10;            float currentVolume;&#10;            audioMixer.GetFloat(volumeParameter, out currentVolume);&#10;            muteToggle.isOn = currentVolume &gt; MuteVolume;&#10;        }&#10;    }&#10;&#10;    private void OnToggleValueChanged(bool isOn)&#10;    {&#10;        if (audioMixer != null)&#10;        {&#10;            audioMixer.SetFloat(volumeParameter, isOn ? UnmuteVolume : MuteVolume);&#10;        }&#10;    }&#10;&#10;    private void OnDestroy()&#10;    {&#10;        if (muteToggle != null)&#10;        {&#10;            muteToggle.onValueChanged.RemoveListener(OnToggleValueChanged);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Project/Scripts/FishSpawner.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Project/Scripts/FishSpawner.cs" />
              <option name="updatedContent" value="using System.Collections;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;public class FishSpawner : MonoBehaviour&#10;{&#10;    [Header(&quot;Настройки спавна&quot;)]&#10;    [SerializeField] private GameObject[] fishPrefabs;           // Массив префабов рыб&#10;    [SerializeField] private float spawnInterval = 2f;          // Интервал между спавнами&#10;    [SerializeField] private float minSpawnInterval = 1f;       // Минимальный интервал&#10;    [SerializeField] private float maxSpawnInterval = 4f;       // Максимальный интервал&#10;    &#10;    [Header(&quot;Позиционирование&quot;)]&#10;    [SerializeField] private float spawnDistanceFromScreen = 2f; // Расстояние за экраном для спавна&#10;    [SerializeField] private float minY = -3f;                  // Минимальная Y позиция для спавна&#10;    [SerializeField] private float maxY = 3f;                   // Максимальная Y позиция для спавна&#10;    &#10;    [Header(&quot;Скорость рыб&quot;)]&#10;    [SerializeField] private float minFishSpeed = 1f;           // Минимальная скорость рыбы&#10;    [SerializeField] private float maxFishSpeed = 4f;           // Максимальная скорость рыбы&#10;    &#10;    [Header(&quot;Вероятность направления&quot;)]&#10;    [Range(0f, 1f)]&#10;    [SerializeField] private float rightDirectionChance = 0.5f; // Шанс спавна рыбы справа налево&#10;    &#10;    private Camera mainCamera;&#10;    private float leftSpawnX;&#10;    private float rightSpawnX;&#10;    private bool isSpawning = false;&#10;&#10;    private void Start()&#10;    {&#10;        mainCamera = Camera.main;&#10;        if (mainCamera != null)&#10;        {&#10;            CalculateSpawnBounds();&#10;            StartSpawning();&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;FishSpawner: Главная камера не найдена!&quot;);&#10;        }&#10;    }&#10;&#10;    private void CalculateSpawnBounds()&#10;    {&#10;        // Рассчитываем позиции спавна за пределами экрана&#10;        Vector3 screenBounds = mainCamera.ScreenToWorldPoint(new Vector3(Screen.width, Screen.height, 0));&#10;        &#10;        leftSpawnX = -screenBounds.x - spawnDistanceFromScreen;   // Левая граница спавна&#10;        rightSpawnX = screenBounds.x + spawnDistanceFromScreen;   // Правая граница спавна&#10;    }&#10;&#10;    public void StartSpawning()&#10;    {&#10;        if (!isSpawning &amp;&amp; fishPrefabs.Length &gt; 0)&#10;        {&#10;            isSpawning = true;&#10;            StartCoroutine(SpawnRoutine());&#10;        }&#10;    }&#10;&#10;    public void StopSpawning()&#10;    {&#10;        isSpawning = false;&#10;        StopAllCoroutines();&#10;    }&#10;&#10;    private IEnumerator SpawnRoutine()&#10;    {&#10;        while (isSpawning)&#10;        {&#10;            SpawnFish();&#10;            &#10;            // Случайный интервал между спавнами&#10;            float waitTime = Random.Range(minSpawnInterval, maxSpawnInterval);&#10;            yield return new WaitForSeconds(waitTime);&#10;        }&#10;    }&#10;&#10;    private void SpawnFish()&#10;    {&#10;        if (fishPrefabs.Length == 0) return;&#10;&#10;        // Выбираем случайный префаб рыбы&#10;        GameObject fishPrefab = fishPrefabs[Random.Range(0, fishPrefabs.Length)];&#10;        &#10;        // Определяем направление движения рыбы&#10;        bool moveRight = Random.value &gt; rightDirectionChance;&#10;        &#10;        // Определяем позицию спавна&#10;        Vector3 spawnPosition = GetSpawnPosition(moveRight);&#10;        &#10;        // Создаем рыбу&#10;        GameObject newFish = Instantiate(fishPrefab, spawnPosition, Quaternion.identity);&#10;        &#10;        // Настраиваем компонент Fish&#10;        Fish fishComponent = newFish.GetComponent&lt;Fish&gt;();&#10;        if (fishComponent == null)&#10;        {&#10;            fishComponent = newFish.AddComponent&lt;Fish&gt;();&#10;        }&#10;        &#10;        // Устанавливаем направление и скорость&#10;        fishComponent.SetDirection(moveRight);&#10;        fishComponent.SetSpeed(Random.Range(minFishSpeed, maxFishSpeed));&#10;    }&#10;&#10;    private Vector3 GetSpawnPosition(bool moveRight)&#10;    {&#10;        float spawnX;&#10;        float spawnY = Random.Range(minY, maxY);&#10;        &#10;        if (moveRight)&#10;        {&#10;            // Спавним слева, рыба плывет вправо&#10;            spawnX = leftSpawnX;&#10;        }&#10;        else&#10;        {&#10;            // Спавним справа, рыба плывет влево&#10;            spawnX = rightSpawnX;&#10;        }&#10;        &#10;        return new Vector3(spawnX, spawnY, 0);&#10;    }&#10;&#10;    // Методы для управления спавном во время игры&#10;    public void SetSpawnInterval(float min, float max)&#10;    {&#10;        minSpawnInterval = min;&#10;        maxSpawnInterval = max;&#10;    }&#10;&#10;    public void SetFishSpeed(float min, float max)&#10;    {&#10;        minFishSpeed = min;&#10;        maxFishSpeed = max;&#10;    }&#10;&#10;    public void SetSpawnHeight(float min, float max)&#10;    {&#10;        minY = min;&#10;        maxY = max;&#10;    }&#10;&#10;    // Визуализация границ спавна в редакторе&#10;    private void OnDrawGizmosSelected()&#10;    {&#10;        if (mainCamera == null) return;&#10;&#10;        Vector3 screenBounds = mainCamera.ScreenToWorldPoint(new Vector3(Screen.width, Screen.height, 0));&#10;        &#10;        Gizmos.color = Color.red;&#10;        &#10;        // Левая граница спавна&#10;        Vector3 leftSpawn = new Vector3(-screenBounds.x - spawnDistanceFromScreen, 0, 0);&#10;        Gizmos.DrawLine(leftSpawn + Vector3.up * maxY, leftSpawn + Vector3.up * minY);&#10;        &#10;        // Правая граница спавна&#10;        Vector3 rightSpawn = new Vector3(screenBounds.x + spawnDistanceFromScreen, 0, 0);&#10;        Gizmos.DrawLine(rightSpawn + Vector3.up * maxY, rightSpawn + Vector3.up * minY);&#10;        &#10;        Gizmos.color = Color.yellow;&#10;        &#10;        // Границы экрана&#10;        Gizmos.DrawLine(new Vector3(-screenBounds.x, maxY, 0), new Vector3(-screenBounds.x, minY, 0));&#10;        Gizmos.DrawLine(new Vector3(screenBounds.x, maxY, 0), new Vector3(screenBounds.x, minY, 0));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Project/Scripts/MusicManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Project/Scripts/MusicManager.cs" />
              <option name="updatedContent" value="using System.Collections;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;public class MusicManager : MonoBehaviour&#10;{&#10;    public static MusicManager Instance { get; private set; } // Синглтон&#10;&#10;    [Header(&quot;Настройки музыки&quot;)]&#10;    [SerializeField] private List&lt;AudioClip&gt; musicTracks; // Список музыкальных треков&#10;    [SerializeField] private AudioSource audioSource; // Аудио источник для воспроизведения&#10;&#10;    private int currentTrackIndex = 0;&#10;&#10;    private void Awake()&#10;    {&#10;        if (Instance != null &amp;&amp; Instance != this)&#10;        {&#10;            Destroy(gameObject); // Уничтожаем дубликат синглтона&#10;            return;&#10;        }&#10;&#10;        Instance = this;&#10;        DontDestroyOnLoad(gameObject); // Сохраняем объект между сценами&#10;    }&#10;&#10;    private void Start()&#10;    {&#10;        if (musicTracks.Count &gt; 0 &amp;&amp; audioSource != null)&#10;        {&#10;            StartCoroutine(PlayMusicLoop());&#10;        }&#10;    }&#10;&#10;    private IEnumerator PlayMusicLoop()&#10;    {&#10;        while (true)&#10;        {&#10;            if (!audioSource.isPlaying)&#10;            {&#10;                audioSource.clip = musicTracks[currentTrackIndex];&#10;                audioSource.Play();&#10;&#10;                currentTrackIndex = (currentTrackIndex + 1) % musicTracks.Count; // Переход к следующему треку&#10;            }&#10;&#10;            yield return null; // Ждем следующий кадр&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Project/Scripts/Wallet.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Project/Scripts/Wallet.cs" />
              <option name="originalContent" value="using System;&#10;using UnityEngine;&#10;&#10;public class Wallet : MonoBehaviour&#10;{&#10;    [Header(&quot;Настройки кошелька&quot;)]&#10;    [SerializeField] private int initialBalance = 0; // Начальный баланс&#10;&#10;    private const string WalletKey = &quot;WalletBalance&quot;; // Ключ для сохранения прогресса&#10;    private int currentBalance;&#10;&#10;    public event Action&lt;int&gt; OnBalanceChanged; // Событие для уведомления об изменении баланса&#10;&#10;    private void Awake()&#10;    {&#10;        LoadProgress();&#10;    }&#10;&#10;    // Метод для добавления монет&#10;    public void AddCoins(int amount)&#10;    {&#10;        if (amount &lt; 0) return;&#10;&#10;        currentBalance += amount;&#10;        SaveProgress();&#10;        OnBalanceChanged?.Invoke(currentBalance);&#10;    }&#10;&#10;    // Метод для снятия монет&#10;    public bool SpendCoins(int amount)&#10;    {&#10;        if (amount &lt; 0 || amount &gt; currentBalance) return false;&#10;&#10;        currentBalance -= amount;&#10;        SaveProgress();&#10;        OnBalanceChanged?.Invoke(currentBalance);&#10;        return true;&#10;    }&#10;&#10;    // Получение текущего баланса&#10;    public int GetBalance()&#10;    {&#10;        return currentBalance;&#10;    }&#10;&#10;    // Сохранение прогресса&#10;    private void SaveProgress()&#10;    {&#10;        PlayerPrefs.SetInt(WalletKey, currentBalance);&#10;        PlayerPrefs.Save();&#10;    }&#10;&#10;    // Загрузка прогресса&#10;    private void LoadProgress()&#10;    {&#10;        currentBalance = PlayerPrefs.GetInt(WalletKey, initialBalance);&#10;        OnBalanceChanged?.Invoke(currentBalance);&#10;    }&#10;&#10;    // Сброс прогресса (для тестирования или отладки)&#10;    public void ResetProgress()&#10;    {&#10;        PlayerPrefs.DeleteKey(WalletKey);&#10;        currentBalance = initialBalance;&#10;        OnBalanceChanged?.Invoke(currentBalance);&#10;    }&#10;}&#10;&#10;    private void PlayBalanceChangeSound(int newBalance)&#10;    {&#10;        if (balanceChangeSound != null)&#10;        {&#10;            balanceChangeSound.Play();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;&#10;public class Wallet : MonoBehaviour&#10;{&#10;    [Header(&quot;Настройки кошелька&quot;)]&#10;    [SerializeField] private int initialBalance = 0; // Начальный баланс&#10;&#10;    private const string WalletKey = &quot;WalletBalance&quot;; // Ключ для сохранения прогресса&#10;    private int currentBalance;&#10;&#10;    public event Action&lt;int&gt; OnBalanceChanged; // Событие для уведомления об изменении баланса&#10;&#10;    public static Wallet Instance { get; private set; } // Синглтон&#10;&#10;    private void Awake()&#10;    {&#10;        if (Instance != null &amp;&amp; Instance != this)&#10;        {&#10;            Destroy(gameObject); // Уничтожаем дубликат синглтона&#10;            return;&#10;        }&#10;&#10;        Instance = this;&#10;        DontDestroyOnLoad(gameObject); // Сохраняем объект между сценами&#10;&#10;        LoadProgress();&#10;    }&#10;&#10;    // Метод для добавления монет&#10;    public void AddCoins(int amount)&#10;    {&#10;        if (amount &lt; 0) return;&#10;&#10;        currentBalance += amount;&#10;        SaveProgress();&#10;        OnBalanceChanged?.Invoke(currentBalance);&#10;    }&#10;&#10;    // Метод для снятия монет&#10;    public bool SpendCoins(int amount)&#10;    {&#10;        if (amount &lt; 0 || amount &gt; currentBalance) return false;&#10;&#10;        currentBalance -= amount;&#10;        SaveProgress();&#10;        OnBalanceChanged?.Invoke(currentBalance);&#10;        return true;&#10;    }&#10;&#10;    // Получение текущего баланса&#10;    public int GetBalance()&#10;    {&#10;        return currentBalance;&#10;    }&#10;&#10;    // Сохранение прогресса&#10;    private void SaveProgress()&#10;    {&#10;        PlayerPrefs.SetInt(WalletKey, currentBalance);&#10;        PlayerPrefs.Save();&#10;    }&#10;&#10;    // Загрузка прогресса&#10;    private void LoadProgress()&#10;    {&#10;        currentBalance = PlayerPrefs.GetInt(WalletKey, initialBalance);&#10;        OnBalanceChanged?.Invoke(currentBalance);&#10;    }&#10;&#10;    // Сброс прогресса (для тестирования или отладки)&#10;    public void ResetProgress()&#10;    {&#10;        PlayerPrefs.DeleteKey(WalletKey);&#10;        currentBalance = initialBalance;&#10;        OnBalanceChanged?.Invoke(currentBalance);&#10;    }&#10;&#10;    private void PlayBalanceChangeSound(int newBalance)&#10;    {&#10;        if (balanceChangeSound != null)&#10;        {&#10;            balanceChangeSound.Play();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Project/Scripts/WalletSoundHandler.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Project/Scripts/WalletSoundHandler.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;public class WalletSoundHandler : MonoBehaviour&#10;{&#10;    [Header(&quot;Звук изменения баланса&quot;)]&#10;    [SerializeField] private AudioSource balanceChangeSound;&#10;&#10;    private void St()&#10;    {&#10;        if (Wallet.Instance != null)&#10;        {&#10;            Wallet.Instance.OnBalanceChanged += PlayBalanceChangeSound;&#10;        }&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (Wallet.Instance != null)&#10;        {&#10;            Wallet.Instance.OnBalanceChanged -= PlayBalanceChangeSound;&#10;        }&#10;    }&#10;&#10;    private void PlayBalanceChangeSound(int newBalance)&#10;    {&#10;        Debug.Log(newBalance);&#10;        if (balanceChangeSound != null)&#10;        {&#10;            balanceChangeSound.Play();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;public class WalletSoundHandler : MonoBehaviour&#10;{&#10;    [Header(&quot;Звук изменения баланса&quot;)]&#10;    [SerializeField] private AudioSource balanceChangeSound;&#10;&#10;    public static WalletSoundHandler Instance { get; private set; } // Синглтон&#10;&#10;    private void Awake()&#10;    {&#10;        if (Instance != null &amp;&amp; Instance != this)&#10;        {&#10;            Destroy(gameObject); // Уничтожаем дубликат синглтона&#10;            return;&#10;        }&#10;&#10;        Instance = this;&#10;        DontDestroyOnLoad(gameObject); // Сохраняем объект между сценами&#10;    }&#10;&#10;    private void St()&#10;    {&#10;        if (Wallet.Instance != null)&#10;        {&#10;            Wallet.Instance.OnBalanceChanged += PlayBalanceChangeSound;&#10;        }&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (Wallet.Instance != null)&#10;        {&#10;            Wallet.Instance.OnBalanceChanged -= PlayBalanceChangeSound;&#10;        }&#10;    }&#10;&#10;    private void PlayBalanceChangeSound(int newBalance)&#10;    {&#10;        Debug.Log(newBalance);&#10;        if (balanceChangeSound != null)&#10;        {&#10;            balanceChangeSound.Play();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>